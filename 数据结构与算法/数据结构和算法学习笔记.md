# 学习笔记

* 课程连接<a href="https://www.bilibili.com/video/BV1jW411K7yg?p=1">小甲鱼</a>
* 数据结构与算法是类似与一对CP的关系。
* 算法初体验：1+2+3+...+99+100

  ```C++
  //基本写法
  #include<stdio.h>
  void main()
  {
  int i, sum = 0; n = 100;
  for(i=1; i <= n; i++>)
  {
      sum = sum + i;
  }
  printf("%d",sum);
  }
  ```

  ```c++
  //高斯算法
    #include<stdio.h>
  void main()
  {
  int i, sum = 0; n = 100;
  sum = (1+n)*n/2;
  printf("%d",sum);
  }
  ```

* 以计算机的速度，两个算法都可以快速计算出来，但是，如果将条件换成1加到1千万，差距就可想而知了。
* 什么是算法：
  * 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有序序列，并且每条指令表示一个或多个操作。
  * 就像没有药可以包治百病一样，一个问题可以由多个算法解决，一个算法也不可能具有通解所偶遇问题的能力。
  * 算法具有五个基本特征：输入、输出、有穷性、确定性和可行性。
    * 输入：算法具有零个或多个输入，尽管对于大多数算法来说，输入参数都是必要的。但是有些时候，像打印“hello world!”,就不用什么参数了。
    * 输出：算法至少由一个或多个输出。算法是一定要输出，不需要它输出，那么这个算法的意义何在。输出的形式可以是打印，也可以是返回一个或多个值等等。
    * 有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤早可接受的时间内完成。
    * 确定性：算法在每一个步骤都具有确定的含义，不会出现二义性。算法在一定条件下，只有一条执行路径，相同输入只有唯一的输出结果。
    * 可行性：算法的每一步都必须是可行的，也就是说，每一步都能通过执行有限次数完成。
  * 算法设计的要求：
    * 正确性：算法的正确性是指算法至少应该具有输入，输出和加工处理无歧义性，能正确反映问题的需求、能够得到问题的正确答案。大体分为以下四个层次：1、算法程序没有语法错误；2、算法程序对于合法输入能够产生满足要求的输出；3、算法程序对于非法输入能够产生满足规格的说明4、算法程序对于故意刁难的测试输入都有满足要求的输出结果。
    * 可读性：算法顺序利益目的是为了便于阅读理解和交流。我写代码的目的一方面是为了让计算机执行，但还有一个重要的目的是为了便于他人阅读和自己日后阅读修改。
    * 键壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常崩溃和莫名其妙的结果。
    * 继续学习<a href="https://www.bilibili.com/video/BV1jW411K7yg?p=4">点这P4</a>

## java数据结构与算法（尚硅谷）

* 课程链接<a href ="https://www.bilibili.com/video/BV1E4411H73v?p=1">尚硅谷</a>
* 继续学习<a href="https://www.bilibili.com/video/BV1E4411H73v?p=9">点这P9</a>

### **1、稀疏数组**

```java
public class Test{//二维数组转稀疏数组
    public static void main(String[] args) {
        System.out.println("原始数组为");
        int chressArr[][] = new int[11][11];
        chressArr[1][2] = 1;
        chressArr[2][3] = 2;
        chressArr[4][3] = 2;
        for(int[] row:chressArr) {
            for (int s : row) {
                System.out.printf("%d\t",s);
            }
            System.out.println();
        }
        //判断二维数组中不为0的数据个数
        int sum = 0;
        for(int i = 0;i<11;i++)
        {
            for(int j = 0;j<11;j++)
            {
                if(chressArr[i][j] !=0){
                    sum++;
                }
            }
        }
        System.out.println("sum = "+sum);
        //创建对应的稀疏数组
        int sparseArr[][] = new int[sum+1][3];
        //给稀疏数组赋值
        sparseArr[0][0] = 11;
        sparseArr[0][1] = 11;
        sparseArr[0][2] = sum;

        int count = 0;
        for(int i = 0;i<11;i++)
        {
            for(int j = 0;j<11;j++)
            {
                if(chressArr[i][j] !=0){
                    count++;
                    sparseArr[count][0]=i;
                    sparseArr[count][1]=j;
                    sparseArr[count][2]=chressArr[i][j];
                }
            }
        }
        System.out.println("稀疏数组为");
        for(int i=0;i<sparseArr.length;i++){
            System.out.printf("%d\t%d\t%d\t\n",sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]);
        }
        System.out.println();


        //稀疏数组转为二维数组
        int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];
        for(int i = 1;i<sparseArr.length;i++){
            chessArr2[sparseArr[i][0]][sparseArr[i][1]]=sparseArr[i][2];
        }
        System.out.println("恢复的原始二维数组");
        for(int[] row:chessArr2) {
            for (int s : row) {
                System.out.printf("%d\t",s);
            }
            System.out.println();
        }
        }
    }
```

### **2、队列**

* 队列是一个有序列表，可以用数组或是链表来实现。
* 遵循先进先出的原则。即：先迅如队列的数据，要先取出，后存入的要后取出。
* 队列本身是有序列表。若使用数组的结构来存储队列的数据，因为队列的输出、输入是分别从前后端来处理，因此需要两个变量fornt和rear分别记录队列的前后端的下标，front会随着输出而改变，而rear则是随着数据输入而改变。

```java
package com.air.structure.Queue;

import java.util.Scanner;
//该方法实现的队列只能使用一次，不能复用
public class QueueTest01 {
    public static void main(String[] args) {//数组模拟队列
        System.out.println("Hello world");
        Queue queue = new Queue(4);
        boolean loop = true;
        while (loop) {
            System.out.println("a:添加数据");
            System.out.println("g:获取数据");
            System.out.println("s:查看队列");
            System.out.println("h:查看头数据");
            Scanner scanner =new Scanner(System.in);
            String x = scanner.next();
            int y;
            switch (x)
            {
                case "a":
                    System.out.println("请输入一个数据");queue.addQueue(y=scanner.nextInt());break;
                case "g":try {
                    System.out.println(queue.getQueue());break;
                }
                catch (Exception e)
                {
                    System.out.println(e.getMessage());break;
                }
                case "s":try {
                    queue.showQueue();break;
                }
                catch (Exception e)
                {
                    System.out.println(e.getMessage());break;
                }
                case "h":try {
                    System.out.println(queue.headQueue());break;
                }
                catch (Exception e)
                {
                    System.out.println(e.getMessage());
                }
            }

        /*int get = queue.getQueue();
        System.out.println(get);*/
        }
    }
}

class Queue{
    private int MaxSize;
    private int front;
    private int rear;
    private int[] arr;
    public Queue(int arrMaxSize){
        MaxSize = arrMaxSize;
        front = -1;
        rear = -1;
        arr = new int[MaxSize];
    }
    public boolean isFull(){//判断队列是否为满
        return rear == MaxSize-1;
    }
    public boolean isEmpty(){//判断队列是否为空
        return rear == front;
    }
    public void addQueue(int n){//添加数据到队列
        //先判断队列是否为满
        if(isFull()){
            System.out.println("F队列已满，不能添加数据！");
            return;
        }
        rear++;
        arr[rear] = n;
    }
    public int getQueue() {//获取队列的数据，出队列
        //判断队列是否为空
        if (isEmpty()) {
            //通过抛出异常
            throw new RuntimeException("G队列空，不能获取数据！");
        }
        front++;
        return arr[front];
    }
    public void showQueue(){//显示队列的所有数据
        //遍历
        if(isEmpty()){
            System.out.println("S队列为空，没有数据！");
            return;
        }
        for(int i = 0;i<arr.length;i++){
            System.out.printf("arr[%d]=%d\n",i,arr[i]);
        }
    }
    public int headQueue(){//显示队列的头数据
        //判断
        if(isEmpty()){
            throw new RuntimeException("H队列为空，无头数据");
        }
        return arr[front+1];
    }
}
```

* 使用数组实现环形队列
*  思路分析
    * front变量的含义做一个调整：front指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素。front的初始值为0。
    * rear变量的含义做一个调整：rear指向队列最左后一个元素的后一个位置，因为希望空出一个空间作为约定。rear的初始值为0。
    * 当队列满时，条件是(rear+1)%MaxSize = front(满)
    * 队列为空的条件，rear== front(空)
    * 这样调整后，队列中有效的数据个数为：(rear+MaxSize-front)%MaxSize
    
```java
   package com.air.structure.Queue02;
   
   import java.util.Scanner;
   //该方法实现的队列只能使用一次，不能复用
   public class QueueTest02 {
       public static void main(String[] args) {//数组模拟队列
           Queue queue = new Queue(7);
           boolean loop = true;
           while (loop) {
               System.out.println("对QueueTest01程序的改进，可实现复用");
               System.out.println("a:添加数据");
               System.out.println("g:获取数据");
               System.out.println("s:查看队列");
               System.out.println("h:查看头数据");
               Scanner scanner =new Scanner(System.in);
               String x = scanner.next();
               int y;
               switch (x)
               {
                   case "a":
                       System.out.println("请输入一个数据");queue.addQueue(y=scanner.nextInt());break;
                   case "g":try {
                       System.out.println(queue.getQueue());break;
                   }
                   catch (Exception e)
                   {
                       System.out.println(e.getMessage());break;
                   }
                   case "s":try {
                       queue.showQueue();break;
                   }
                   catch (Exception e)
                   {
                       System.out.println(e.getMessage());break;
                   }
                   case "h":try {
                       System.out.println(queue.headQueue());break;
                   }
                   catch (Exception e)
                   {
                       System.out.println(e.getMessage());
                   }
               }
   
           /*int get = queue.getQueue();
           System.out.println(get);*/
           }
       }
   }
   
   class Queue{
       private int MaxSize;
       private int front;
       private int rear;
       private int[] arr;
       public Queue(int arrMaxSize){
           MaxSize = arrMaxSize;
   //        front = -1;
   //        rear = -1;
           arr = new int[MaxSize];
       }
       public boolean isFull(){//判断队列是否为满
   //        return rear == MaxSize-1;
           return (rear+1)%MaxSize == front;
       }
       public boolean isEmpty(){//判断队列是否为空
           return rear == front;
       }
       public void addQueue(int n){//添加数据到队列
           //先判断队列是否为满
           if(isFull()){
               System.out.println("F队列已满，不能添加数据！");
               return;
           }
           /*rear++;
           arr[rear] = n;*/
           arr[rear] = n;
           //将rear后移，这里必须考虑取模
           rear = (rear+1)%MaxSize;
       }
       public int getQueue() {//获取队列的数据，出队列
           //判断队列是否为空
           if (isEmpty()) {
               //通过抛出异常
               throw new RuntimeException("G队列空，不能获取数据！");
           }
           /*front++;
           return arr[front];*/
           //这里需要分析出front时指向队列的第一个元素
           //先把front对应的值保留到一个临时变量
           //将front后移,考虑取模
           //将临时变量保存的值返回
           int value =arr[front];
           front = ( front + 1 ) % MaxSize;
           return value;
       }
       public void showQueue(){//显示队列的所有数据
           //遍历
           //思路：从front开始遍历，遍历多少个元素
   
           if(isEmpty()){
               System.out.println("S队列为空，没有数据！");
               return;
           }
   //        for(int i = 0;i<arr.length;i++){
   //            System.out.printf("arr[%d]=%d\n",i,arr[i]);
                   for(int i = front;i<size();i++){
               System.out.printf("arr[%d]=%d\n",i%MaxSize,arr[i%MaxSize]);
           }
       }
       //求出当前队列有效数据的个数
       public int size(){
           return (rear+MaxSize-front)%MaxSize;
       }
       public int headQueue(){//显示队列的头数据
           //判断
           if(isEmpty()){
               throw new RuntimeException("H队列为空，无头数据");
           }
           return arr[front];
       }
   }
```

### **3、链表**

* 继续学习<a href="https://www.bilibili.com/video/BV1E4411H73v?p=16">点这P16</a>